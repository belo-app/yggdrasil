{"version":3,"sources":["../src/utils/csv.ts"],"names":["parse","RemoteChunkSize","unparse","CsvHandler","jsonToCsv","data","options","Buffer","from","csvToJsonAsync","file","onChunk","config","chunkNumber","errors","Promise","resolve","reject","error","chunkSize","complete","_result","chunk","result","pause","logger","info","process","push","resume","csvToJson","csvHandler"],"mappings":";;;;;;;;AAAA,SACEA,OAMAC,iBACAC,eAEK;AAKA,IAAMC,aAAN,MAAMA;EACJC,UAAUC,MAA6BC,SAAyB;AACrE,WAAOC,OAAOC,KAAKN,QAAQG,MAAMC,OAAAA,CAAAA;EACnC;EAEA,MAAaG,eACXC,MACAC,SAIAC,QAC4C;AAC5C,QAAIC,cAAc;AAClB,UAAMR,OAAiB,CAAA;AACvB,UAAMS,SAAgB,CAAA;AAEtB,WAAO,IAAIC,QAAQ,CAACC,SAASC,WAAW;AACtCjB,YAAMU,MAAa;QACjBQ,OAAOD;QACPE,WAAWlB;QACX,GAAGW;QACHQ,UAAU,CAACC,YAAgCL,QAAQ;UAAEX;UAAMS;QAAO,CAAA;QAClEQ,OAAO,OAAOC,QAA4BvB,WAAkB;AAC1DA,UAAAA,OAAMwB,MAAK;AACXC,iBAAOC,KAAK,kBAAkBb,aAAa;AAE3C,gBAAMc,UAAU,MAAMhB,QAAQY,OAAOlB,MAAMkB,OAAOT,MAAM;AAExDT,eAAKuB,KAAKD,QAAQtB,IAAI;AACtBS,iBAAOc,KAAKD,QAAQT,KAAK;AAEzBL,yBAAe;AACfb,UAAAA,OAAM6B,OAAM;QACd;MACF,CAAA;IACF,CAAA;EACF;EAEA,MAAaC,UACXpB,MACAE,QAC6B;AAC7B,WAAO,IAAIG,QAAQ,CAACC,SAASC,WAAW;AACtCjB,YAAMU,MAAa;QACjBQ,OAAOD;QACP,GAAGL;QACHQ,UAAU,CAACG,WAA+BP,QAAQO,MAAAA;MACpD,CAAA;IACF,CAAA;EACF;AACF;AAnDapB;AAqDN,IAAM4B,aAAa,IAAI5B,WAAAA","sourcesContent":["import {\n  parse,\n  ParseConfig,\n  ParseError,\n  Parser,\n  ParseResult,\n  ParseWorkerConfig,\n  RemoteChunkSize,\n  unparse,\n  UnparseConfig,\n} from \"papaparse\";\nimport { Stream } from \"stream\";\n\nimport { logger } from \"./logger\";\n\nexport class CsvHandler {\n  public jsonToCsv(data: Record<string, any>[], options?: UnparseConfig) {\n    return Buffer.from(unparse(data, options));\n  }\n\n  public async csvToJsonAsync<Input, Output>(\n    file: Stream,\n    onChunk: (\n      data: Input[],\n      errors: ParseError[]\n    ) => Promise<{ data: Output; error: any }>,\n    config?: Partial<ParseWorkerConfig>\n  ): Promise<{ data: Output[]; errors: any[] }> {\n    let chunkNumber = 1;\n    const data: Output[] = [];\n    const errors: any[] = [];\n\n    return new Promise((resolve, reject) => {\n      parse(file as any, {\n        error: reject,\n        chunkSize: RemoteChunkSize,\n        ...config,\n        complete: (_result: ParseResult<Input>) => resolve({ data, errors }),\n        chunk: async (result: ParseResult<Input>, parse: Parser) => {\n          parse.pause();\n          logger.info(`Chunck Number: ${chunkNumber}`);\n\n          const process = await onChunk(result.data, result.errors);\n\n          data.push(process.data);\n          errors.push(process.error);\n\n          chunkNumber += 1;\n          parse.resume();\n        },\n      });\n    });\n  }\n\n  public async csvToJson<Input>(\n    file: Stream,\n    config?: ParseConfig\n  ): Promise<ParseResult<Input>> {\n    return new Promise((resolve, reject) => {\n      parse(file as any, {\n        error: reject,\n        ...config,\n        complete: (result: ParseResult<Input>) => resolve(result),\n      });\n    });\n  }\n}\n\nexport const csvHandler = new CsvHandler();\n"]}