{"version":3,"sources":["../src/utils/lock.ts"],"names":["Redis","memoize","Redlock","getRedis","environment","REDIS_URL","enableOfflineQueue","Lock","constructor","key","options","redis","redlock","driftFactor","retryCount","retryLimit","retryDelay","retryInterval","retryJitter","automaticExtensionThreshold","acquireDuration","isFree","using","keys","Promise","resolve","acquire","asyncFunction","throwError","lock","error","logger","Errors","lockCouldNotAcquireKeys","finally","release","catch","Array","isArray"],"mappings":";;;;;;;;;;;;;;AAAA,OAAOA,WAAW;AAClB,OAAOC,aAAa;AACpB,OAAOC,aAAa;AAQpB,IAAMC,WAAWF,QAAQ,MAAM;AAC7B,SAAO,IAAID,MAAMI,YAAYC,WAAW;IACtCC,oBAAoB;EACtB,CAAA;AACF,CAAA;AAEO,IAAMC,OAAN,MAAMA;EAIXC,YACUC,KACRC,SAKA;eANQD;AAOR,UAAME,QAAQR,SAAAA;AAEd,SAAKS,UAAU,IAAIV,QAAQ;MAACS;OAAQ;MAClCE,aAAa;MACbC,YAAYJ,SAASK,cAAc;MACnCC,YAAYN,SAASO,iBAAiB;MACtCC,aAAa;MACbC,6BAA6B;IAC/B,CAAA;AAEA,SAAKC,kBAAkBV,SAASU,mBAAmB;EACrD;EAEA,MAAaC,SAAS;AACpB,QAAI;AACF,YAAM,KAAKT,QAAQU,MAAM,KAAKC,MAAM,KAAM;QAAET,YAAY;MAAE,GAAG,MAC3DU,QAAQC,QAAO,CAAA;IAEnB,QAAE;AACA,aAAO;IACT;AAEA,WAAO;EACT;EAEA,MAAaC,QACXC,eACAC,aAAa,OACD;AACZ,QAAIC;AAEJ,QAAI;AACFA,aAAO,MAAM,KAAKjB,QAAQc,QAAQ,KAAKH,MAAM,KAAKH,eAAe;IACnE,SAASU,OAAP;AACAC,aAAOD,MAAM,0BAA0B,KAAKrB,OAAO;QACjDqB;QACArB,KAAK,KAAKA;MACZ,CAAA;AACA,UAAImB,YAAY;AACd,cAAMI,OAAOC,wBAAwB,0BAA0B;UAC7DV,MAAM,KAAKd;UACXqB;QACF,CAAA;MACF;IACF;AAEA,WAAOH,cAAAA,EAAgBO,QAAQ,MAC7BL,MAAMM,QAAAA,EAAUC,MAAM,CAACN,UACrBC,OAAOD,MAAM,kCAAkC,KAAKrB,OAAO;MACzDqB;MACArB,KAAK,KAAKA;IACZ,CAAA,CAAA,CAAA;EAGN;EAEA,IAAYc,OAAO;AACjB,WAAOc,MAAMC,QAAQ,KAAK7B,GAAG,IAAI,KAAKA,MAAM;MAAC,KAAKA;;EACpD;AACF;AAvEaF","sourcesContent":["import Redis from \"ioredis\";\nimport memoize from \"memoizee\";\nimport Redlock from \"redlock\";\n\nimport { environment } from \"./environment\";\nimport { Errors } from \"./error\";\nimport { logger } from \"./logger\";\n\nexport type AsyncFunction<T> = () => Promise<T>;\n\nconst getRedis = memoize(() => {\n  return new Redis(environment.REDIS_URL, {\n    enableOfflineQueue: false,\n  });\n});\n\nexport class Lock {\n  private redlock: Redlock;\n  private acquireDuration: number;\n\n  constructor(\n    private key: string | string[],\n    options?: Partial<{\n      retryInterval: number;\n      retryLimit: number;\n      acquireDuration: number;\n    }>\n  ) {\n    const redis = getRedis();\n\n    this.redlock = new Redlock([redis], {\n      driftFactor: 0.01,\n      retryCount: options?.retryLimit ?? 20,\n      retryDelay: options?.retryInterval ?? 500,\n      retryJitter: 100,\n      automaticExtensionThreshold: 500,\n    });\n\n    this.acquireDuration = options?.acquireDuration ?? 50_000;\n  }\n\n  public async isFree() {\n    try {\n      await this.redlock.using(this.keys, 1000, { retryCount: 0 }, () =>\n        Promise.resolve()\n      );\n    } catch {\n      return false;\n    }\n\n    return true;\n  }\n\n  public async acquire<T>(\n    asyncFunction: AsyncFunction<T>,\n    throwError = false\n  ): Promise<T> {\n    let lock;\n\n    try {\n      lock = await this.redlock.acquire(this.keys, this.acquireDuration);\n    } catch (error) {\n      logger.error(`Could not acquire lock ${this.key}`, {\n        error,\n        key: this.key,\n      });\n      if (throwError) {\n        throw Errors.lockCouldNotAcquireKeys(\"Could not acquire keys\", {\n          keys: this.key,\n          error,\n        });\n      }\n    }\n\n    return asyncFunction().finally(() =>\n      lock?.release().catch((error) =>\n        logger.error(`Could not release lock for key ${this.key}`, {\n          error,\n          key: this.key,\n        })\n      )\n    );\n  }\n\n  private get keys() {\n    return Array.isArray(this.key) ? this.key : [this.key];\n  }\n}\n"]}