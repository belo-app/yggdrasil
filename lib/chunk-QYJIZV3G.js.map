{"version":3,"sources":["../src/utils/influx.ts"],"names":["InfluxDB","Point","dayjs","memoize","os","org","bucket","getInfluxWriteApi","client","url","token","environment","INFLUX_TOKEN","writeApi","getWriteApi","useDefaultTags","host","hostname","release","GIT_SHA","service","influxQueue","batchQueue","points","writePoints","flush","catch","writeInfluxPoint","point","LOCAL","random","Math","add","trackTime","metric","tags","start","elapsed","diff","uintField","key","value","Object","entries","tag","instrument","data","target","descriptor","originalMethod","handler","parameters","endTrackTime","result","apply","isPromise","then","finally"],"mappings":";;;;;;;;;;;AAAA,SAASA,UAAUC,aAAa;AAChC,OAAOC,WAAW;AAClB,OAAOC,aAAa;AACpB,OAAOC,QAAQ;AAKf,IAAMC,MAAM;AACZ,IAAMC,SAAS;AAEf,IAAMC,oBAAoBJ,QAAQ,MAAM;AACtC,QAAMK,SAAS,IAAIR,SAAS;IAC1BS,KAAK;IACLC,OAAOC,YAAYC;EACrB,CAAA;AAEA,QAAMC,WAAWL,OAAOM,YAAYT,KAAKC,MAAAA;AAEzCO,WAASE,eAAe;IACtBC,MAAMZ,GAAGa,SAAQ;IACjBC,SAASP,YAAYQ;IACrBC,SAAS;EACX,CAAA;AAEA,SAAOP;AACT,CAAA;AAEA,IAAMQ,cAAcC,WAAkB,CAACC,WAAW;AAChDhB,oBAAAA,EAAoBiB,YAAYD,MAAAA;AAEhChB,oBAAAA,EACGkB,MAAK,EACLC,MAAM,MAAM,MAAK;AACtB,CAAA;AAEO,IAAMC,mBAAmB,wBAACC,UAAiB;AAChD,MAAIjB,YAAYkB,OAAO;AACrB;EACF;AAEA,QAAMC,SAASC,KAAKD,OAAM;AAE1B,MAAIA,SAAS,KAAK;AAChB;EACF;AAEAT,cAAYW,IAAIJ,KAAAA;AAClB,GAZgC;AAczB,IAAMK,YAAY,wBACvBC,QACAC,OAA+B,CAAC,MAC7B;AACH,QAAMC,QAAQlC,MAAAA;AAEd,SAAO,MAAM;AACX,UAAMmC,UAAUnC,MAAAA,EAAQoC,KAAKF,OAAO,cAAA;AACpC,QAAIR,QAAQ,IAAI3B,MAAMiC,MAAAA,EAAQK,UAAU,WAAWF,OAAAA;AAEnD,eAAW,CAACG,KAAKC,KAAAA,KAAUC,OAAOC,QAAQR,IAAAA,GAAO;AAC/C,UAAIK,OAAOC,OAAO;AAChBb,gBAAQA,MAAMgB,IAAIJ,KAAKC,KAAAA;MACzB;IACF;AAEAd,qBAAiBC,KAAAA;EACnB;AACF,GAlByB;AAyBlB,IAAMiB,aACX,wBAACX,QAAQY,OAAO,CAAC,MACjB,CAAIC,QAAQP,KAAKQ,eAAe;AAC9B,QAAMC,iBAAiBD,YAAYP,SAASM,OAAOP;AAEnD,QAAMU,UAAU,mCAAaC,YAAmB;AAC9C,UAAMC,eAAenB,UAAUC,QAAQY,IAAAA;AAEvC,UAAMO,SAASJ,eAAeK,MAAMP,QAAQI,UAAAA;AAC5C,UAAMI,YAAY,OAAOF,OAAOG,SAAS;AAEzC,QAAID,WAAW;AACb,aAAOF,OAAOI,QAAQL,YAAAA;IACxB;AAEAA,iBAAAA;AAEA,WAAOC;EACT,GAbgB;AAehB,MAAIL,WAAWP,OAAO;AACpBO,eAAWP,QAAQS;AAEnB,WAAOF;EACT;AAEAD,SAAOP,OAAOU;AAChB,GA1BA","sourcesContent":["import { InfluxDB, Point } from \"@influxdata/influxdb-client\";\nimport dayjs from \"dayjs\";\nimport memoize from \"memoizee\";\nimport os from \"os\";\n\nimport { batchQueue } from \"./batch-queue\";\nimport { environment } from \"./environment\";\n\nconst org = \"belo\";\nconst bucket = \"belo\";\n\nconst getInfluxWriteApi = memoize(() => {\n  const client = new InfluxDB({\n    url: \"https://us-east-1-1.aws.cloud2.influxdata.com\",\n    token: environment.INFLUX_TOKEN,\n  });\n\n  const writeApi = client.getWriteApi(org, bucket);\n\n  writeApi.useDefaultTags({\n    host: os.hostname(),\n    release: environment.GIT_SHA,\n    service: \"core\",\n  });\n\n  return writeApi;\n});\n\nconst influxQueue = batchQueue<Point>((points) => {\n  getInfluxWriteApi().writePoints(points);\n\n  getInfluxWriteApi()\n    .flush()\n    .catch(() => void 0);\n});\n\nexport const writeInfluxPoint = (point: Point) => {\n  if (environment.LOCAL) {\n    return;\n  }\n\n  const random = Math.random();\n\n  if (random < 0.2) {\n    return;\n  }\n\n  influxQueue.add(point);\n};\n\nexport const trackTime = (\n  metric: string,\n  tags: Record<string, string> = {}\n) => {\n  const start = dayjs();\n\n  return () => {\n    const elapsed = dayjs().diff(start, \"milliseconds\");\n    let point = new Point(metric).uintField(\"elapsed\", elapsed);\n\n    for (const [key, value] of Object.entries(tags)) {\n      if (key && value) {\n        point = point.tag(key, value);\n      }\n    }\n\n    writeInfluxPoint(point);\n  };\n};\n\nexport type InstrumentDecorator = (\n  metric: string,\n  data?: Record<string, string>\n) => MethodDecorator;\n\nexport const instrument: InstrumentDecorator =\n  (metric, data = {}) =>\n  <T>(target, key, descriptor) => {\n    const originalMethod = descriptor?.value ?? target[key];\n\n    const handler = function (...parameters: any[]) {\n      const endTrackTime = trackTime(metric, data);\n\n      const result = originalMethod.apply(target, parameters) as Promise<T>;\n      const isPromise = typeof result.then === \"function\";\n\n      if (isPromise) {\n        return result.finally(endTrackTime);\n      }\n\n      endTrackTime();\n\n      return result;\n    };\n\n    if (descriptor.value) {\n      descriptor.value = handler;\n\n      return descriptor;\n    }\n\n    target[key] = handler;\n  };\n"]}